drop schema if exists app_public cascade;
drop schema if exists app_private cascade;

create schema app_public;
create schema app_private;

-- this line should be placed before any function definition
alter default privileges revoke execute on functions from public;

-- person

create table app_public.person (
  id integer primary key generated by default as identity,
  first_name varchar(120) not null,
  last_name varchar(120),
  about text,
  created_at timestamp default now(),
  updated_at timestamp default now()
);

create function app_public.person_full_name (
  person app_public.person
) returns text as $$
  select person.first_name || ' ' || person.last_name
$$ language sql stable;

create function app_public.person_lastest_post (
  person app_public.person
) returns app_public.post as $$
  select *
  from app_public.post as post
  where post.author_id = person.id
  order by created_at desc
  limit 1
$$ language sql stable;

-- post

create type app_public.post_topic as enum (
  'discussion',
  'inspration',
  'help',
  'showcase'
);

create table app_public.post (
  id integer primary key generated by default as identity,
  author_id integer not null references app_public.person(id),
  topic app_public.post_topic,
  title varchar(255) NOT NULL,
  body text,
  created_at timestamp default now(),
  updated_at timestamp default now()
);

create function app_public.post_summary (
  post app_public.post,
  length int default 50,
  omission text default '...'
) returns text as $$
  select case
    when post.body is null then null
    else substr(post.body, 0, length) || omission
  end
$$ language sql stable;

create function app_public.search_post(
  search text
) returns setof app_public.post as $$
  select *
  from app_public.post as post
  where position(search in post.title) > 0 or position(search in post.body) > 0
$$ language sql stable;


-- trigger 
create function app_private.set_updated_at() returns trigger as $$
begin
  new.updated_at := now();
  return new;
end;
$$ language plpgsql;

create trigger person_updated_at before update
  on app_public.person
  for each row
  execute procedure app_private.set_updated_at();

create trigger post_updated_at before update
  on app_public.post
  for each row
  execute procedure app_private.set_updated_at();

-- authorization

create table app_private.person_account (
  person_id int primary key references app_public.person(id) on delete cascade,
  email varchar(120) not null unique check(email ~* '^.+@.+\..+$'),
  password_hash varchar(255) not null
);


create extension if not exists "pgcrypto";

create function app_public.register_account (
  first_name text,
  last_name text,
  email text,
  password text
) returns app_public.person as $$
declare
  person app_public.person;
begin
  insert into app_public.person(
    first_name,
    last_name
  ) values (first_name, last_name)
  returning * into person;

  insert into app_private.person_account (
    person_id,
    email,
    password_hash
  ) values (
    person.id,
    email,
    crypt(password, gen_salt('bf'))
  );

  return person;
end;
$$ language plpgsql strict security definer;

create type app_public.jwt_token as (
  role text,
  person_id int,
  ext bigint
);

create function app_public.authenticate (
  email text,
  password text
) returns app_public.jwt_token as $$
declare
  account app_private.person_account;
begin
  select * into account
  from app_private.person_account as a
  where a.email = $1;

  if account.password_hash = crypt(password, account.password_hash) then
    return (
      'app_person',
      account.person_id,
      extract(epoch from(now() + interval '2 days'))
    )::app_public.jwt_token;
  else
    return null;
  end if;
end;
$$ language plpgsql strict security definer;

-- grant roles

create role app_admin login password 'xyz';

create role app_anonymous;
grant app_anonymous to app_admin;

create role app_person;
grant app_person to app_admin;


grant usage on schema app_public to app_anonymous, app_person;

grant select on table app_public.person to app_anonymous, app_person; 
grant update, delete on table app_public.person to app_person; 

grant select on table app_public.post to app_anonymous, app_person; 
grant insert, update, delete on table app_public.post to app_person; 
